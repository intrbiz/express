options {
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(ELParser)

package com.intrbiz.express.parser;

import com.intrbiz.express.*;
import com.intrbiz.express.operator.*;
import com.intrbiz.express.statement.*;
import java.util.*;

@SuppressWarnings("all")
public final class ELParser {

}

PARSER_END(ELParser)

<DEFAULT> TOKEN:
{
    <NON_EXPRESSION_TEXT: (~["#", "<"])+ | ("#" (~["{", "#"])+) | "#" | ("<" (~["#", "<"])+) | "<" >
  | <START_EXPRESSION: "#{" > : IN_EXPRESSION
  | <START_SCRIPT: "<#" > : IN_SCRIPT
}


<IN_EXPRESSION, IN_SCRIPT> SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" }
<IN_EXPRESSION, IN_SCRIPT> TOKEN : 
{ 
    <#DIGITS : (["0"-"9"])+ > 
  | <DOT : "." >
  | <ADD : "+" >
  | <SUB : "-" >
  | <MUL : "*" >
  | <DIV : "/" >
  | <DIV1 : "div" >
  | <POW : "^" >
  | <MOD : "%" >
  | <MOD1 : "mod" >
  | <EQ : "==" >
  | <EQ1 : "eq" >
  | <NE : "!=" >
  | <NE1 : "ne" >
  | <GT : ">" >
  | <GT1 : "gt" >
  | <LT : "<" >
  | <LT1 : "lt" >
  | <GTEQ : ">=" >
  | <GTEQ1 : "gteq" >
  | <LTEQ : "<=" >
  | <LTEQ1 : "lteq" >
  | <OR : "||" >
  | <OR1 : "or" >
  | <AND : "&&" >
  | <AND1 : "and" >
  | <NOT : "!" >
  | <NOT1 : "not" >
  | <STCOMP : "(" >
  | <EDCOMP : ")" >
  | <ARGSEP : "," >
  | <STARR  : "[" >
  | <EDARR  : "]" >
  | <ASSIGNMENT : "=" >
  | <ADDASSIGNMENT : "+=" >
  | <SUBASSIGNMENT : "-=" >
  | <MULASSIGNMENT : "*=" >
  | <DIVASSIGNMENT : "/=" >
  | <POWASSIGNMENT : "^=" >
  | <MODASSIGNMENT : "%=" >
  | <INCASSIGNMENT : "++" >
  | <DECASSIGNMENT : "--" >
  | <NEW    : "new" >
  | <RETURN : "return" >
  | <IF     : "if" >
  | <ELSE   : "else" >
  | <IN     : "in" >
  | <FOR    : "for" >
  | <WHILE  : "while" >
  | <BREAK  : "break" >
  | <EXPORT  : "export" >
  | <INCLUDE : "include" >
  | <LACTION       : "@" >
  | <NLINT : <DIGITS> > 
  | <NLLONG : <DIGITS> "L" > 
  | <NLFLOAT : <DIGITS> "." <DIGITS> > 
  | <NLDOUBLE : <DIGITS> "." <DIGITS> "D" | <DIGITS> "D" > 
  | <LBOOLEAN : "true" | "TRUE" | "false" | "FALSE" > 
  | <LNULL : "null" | "NULL" >
  | <LENTITY : ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9","_"])* >
  | <#HEXCHAR : ["a"-"f","A"-"F","0"-"9"]> 
  | <#ESCAPECHAR : "\\" ["n","t","b","r","f","\\","'","\"", "/"] > 
  | <#UESCAPECHAR : "\\u" <HEXCHAR><HEXCHAR><HEXCHAR><HEXCHAR> > 
  | <LSTRING : "\'" ( (~["\'","\\","\n","\r"]) | <ESCAPECHAR> | <UESCAPECHAR>)* "\'" >
}

<IN_EXPRESSION> TOKEN :
{
    <END_EXPRESSION: "}" > : DEFAULT
  | <QUOTE : "\"" > : STRINGSTATE
}

<IN_SCRIPT> TOKEN : 
{
    <STARTBLOCK : "{" >
  | <ENDBLOCK   : "}" >
  | <STATEMENT  : ";" >
  | <END_SCRIPT : "#>" > : DEFAULT
}

<STRINGSTATE> MORE  : { "\\" : ESCSTATE }
<STRINGSTATE> TOKEN : { <ENDQUOTE : <QUOTE> > : IN_EXPRESSION | <CHAR : ~["\"","\\"]> }
<ESCSTATE> TOKEN : { <CNTRLESC : ["\'","\\","/","b","f","n","r","t"]> : STRINGSTATE }
<ESCSTATE> MORE  : { "u" : HEXSTATE }
<HEXSTATE> TOKEN : { <#HEX : ["a"-"f","A"-"F","0"-"9"]> | <HEXESC : <HEX><HEX><HEX><HEX> > : STRINGSTATE }


private PlainLiteral readPlainText(ExpressContext c) throws ExpressException :
{
  Token t;
}
{
  t = <NON_EXPRESSION_TEXT>
  { return new PlainLiteral(t.image); }
}

private PlainWriteStatement readPlainWriteStatement(ExpressContext c) throws ExpressException :
{
  Token t;
}
{
  t = <NON_EXPRESSION_TEXT>
  { return new PlainWriteStatement(t.image); }
}

private IntLiteral readIntLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <NLINT>
    {return new IntLiteral( Integer.parseInt(t.image) );}
}

private LongLiteral readLongLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <NLLONG>
    {return new LongLiteral( Long.parseLong( t.image.substring( 0, t.image.length() -1 ) ) );}
}

private FloatLiteral readFloatLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <NLFLOAT>
    {return new FloatLiteral( Float.parseFloat( t.image ) );}
}

private DoubleLiteral readDoubleLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <NLDOUBLE>
    {return new DoubleLiteral( Double.parseDouble( t.image.substring( 0, t.image.length() -1 ) ) );}
}

private BooleanLiteral readBooleanLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <LBOOLEAN>
    {return new BooleanLiteral( Boolean.parseBoolean( t.image ) );}
}

private StringLiteral readStringLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
    StringBuilder builder = new StringBuilder();
}
{
    (
        t = <LSTRING>
        {return new StringLiteral( t.image.substring(1, t.image.length() -1), true );}
    ) | 
    (
        <QUOTE> ( getChar(builder) )* <ENDQUOTE>
        { System.out.println("Quote: '" + builder + "'"); return new StringLiteral( builder.toString(), false );}
    )
}

private void getChar(StringBuilder builder) :
{
  Token t;
}
{
  ( 
    t = <CHAR> 
    { builder.append(t.image); }
  ) | 
  (
    t = <CNTRLESC>
    { builder.append(t.image); }
  ) |
  (
    t = <HEXESC>
    { builder.append(t.image); }
  )
}

private NullLiteral readNullLiteral(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <LNULL>
    {return new NullLiteral();}
}

private String readEntityName(ExpressContext c) throws ExpressException : 
{
    Token t;
}
{
    t = <LENTITY>
    { return t.image;}
}

private Entity readEntityLiteral(ExpressContext c) throws ExpressException : 
{
    String en;
}
{
    en = readEntityName(c)
    {return new Entity( en );}
}

private Literal readNLiteral(ExpressContext c) throws ExpressException :
{
    Literal l;
}
{
    ( l = readIntLiteral(c) | l = readLongLiteral(c) | l = readFloatLiteral(c) | l = readDoubleLiteral(c) )
    { return l; }
}

private Operator readLiteral(ExpressContext c) throws ExpressException :
{
    Operator l;
}
{
    ( 
        l = readNLiteral(c)             | 
        l = readBooleanLiteral(c)       | 
        l = readStringLiteral(c)        | 
        l = readNullLiteral(c)          | 
        l = readEntityLiteral(c)
    )
    { return l; }
}

private Operator readFunction(ExpressContext c) throws ExpressException :
{
    Token ift;
    String fn;
    Function f = null;
    List<Operator> args = new LinkedList<Operator>();
    Map<String,Operator> namedArgs = new TreeMap<String,Operator>();
    Operator a;
    String argName;
}
{
    (
     (
      fn = readEntityName(c) |
      (
       ift = <IF>
       { fn = ift.image; }
      )
     )
     <STCOMP>
     (
          (
              LOOKAHEAD (2)    
              (
                  argName = readEntityName(c)
                  <ASSIGNMENT>
                  a = readExpression(c)
                  { namedArgs.put(argName, a); }
              ) |
              (
                   a = readExpression(c)
                  { args.add(a); }
              )
          )
          (
               <ARGSEP>
               (
                  LOOKAHEAD (2)
                  (
                      argName = readEntityName(c)
                      <ASSIGNMENT>
                      a = readExpression(c)
                      { namedArgs.put(argName, a); }
                  ) |
                  (
                       a = readExpression(c)
                      { args.add(a); }
                  )
              )
          )*
     )?
     <EDCOMP>
    )
    {
    if ("coalesce".equals(fn))
    {
      f = new Coalesce();
    }
    else if ("dateformat".equals(fn))
    {
      f = new DateFormat();
    }
    else if ("double".equals(fn))
    {
      f = new DoubleCast();
    }
    else if ("float".equals(fn))
    {
      f = new FloatCast();
    }
    else if ("long".equals(fn))
    {
      f = new LongCast();
    }
    else if ("int".equals(fn))
    {
      f = new IntCast();
    }
    else if ("string".equals(fn))
    {
      f = new StringCast();
    }
    else if ("list".equals(fn))
    {
      f = new ListCast();
    }
    else if ("getuuid".equals(fn))
    {
      f = new GetUUID();
    }
    else if ("if".equals(fn))
    {
      f = new If();
    }
    else if ("instanceof".equals(fn))
    {
      f = new InstanceOf();
    }
    else if ("isempty".equals(fn))
    {
      f = new IsEmpty();
    }
    else if ("isnull".equals(fn))
    {
      f = new IsNull();
    }
    else if ("urlencode".equals(fn))
    {
      f = new URLEncode();
    }
    else if ("urldecode".equals(fn))
    {
      f = new URLDecode();
    }
    else if ("print".equals(fn))
    {
        f = new Print();
    }
    else if (c != null )
    {
        f = c.getCustomFunction( fn );
    }
    
    if (f == null)
    {
          throw new ExpressException("Could not get function: " + fn);
    }

    f.setParameters(args);
    f.setNamedParameters(namedArgs);
    return f;
    }
}

private Operator readAction(ExpressContext c) throws ExpressException :
{
    String an;
    List<Operator> args = new LinkedList<Operator>();
    Map<String, Operator> namedArgs = new HashMap<String, Operator>();
    String argName;
    Operator a;
}
{
    (
        <LACTION>
        an = readEntityName(c)
        <STCOMP>
        (
              (
                  LOOKAHEAD (2)    
                  (
                      argName = readEntityName(c)
                      <ASSIGNMENT>
                      a = readExpression(c)
                      { namedArgs.put(argName, a); }
                  ) |
                  (
                       a = readExpression(c)
                      { args.add(a); }
                  )
              )
              (
                   <ARGSEP>
                   (
                      LOOKAHEAD (2)
                      (
                          argName = readEntityName(c)
                          <ASSIGNMENT>
                          a = readExpression(c)
                          { namedArgs.put(argName, a); }
                      ) |
                      (
                           a = readExpression(c)
                          { args.add(a); }
                      )
                  )
              )*
         )?
        <EDCOMP>
    )
    {
        return new ActionOperator(an, args, namedArgs);
    }
}

private Operator readValue(ExpressContext c) throws ExpressException : 
{
    Operator v;
}
{
    v = readValuePrefix(c)
    (
    v = readValueSuffix(c,v)
    )*
    { return v; }
}

private Operator readValuePrefix(ExpressContext c) throws ExpressException :
{
    Operator p;
}
{
    (
        (
            <STCOMP> 
            p = readExpression(c) 
            <EDCOMP> 
            { p = new Complex(p); }
        ) |
        LOOKAHEAD(readAction(c))    p = readAction(c)   |
        LOOKAHEAD(readFunction(c))  p = readFunction(c) |
        LOOKAHEAD(readLiteral(c))   p = readLiteral(c)
    )
    { return p; }
}

private Operator readValueSuffix(ExpressContext c, Operator l) throws ExpressException :
{
    Operator o;
}
{
    (LOOKAHEAD(readMethodInvoke(c,l)) o = readMethodInvoke(c,l) | o = readPropertyInvoke(c,l) | o = readArrayInvoke(c,l))
    { return o; }
}

private Operator readPropertyInvoke(ExpressContext c, Operator l) throws ExpressException :
{
    String name;
}
{
    <DOT>
    name = readEntityName(c)
    { return new PropertyInvoke(l, name); }
}

private Operator readArrayInvoke(ExpressContext c, Operator l) throws ExpressException :
{
    Operator r;
}
{
    <STARR>
    r = readExpression(c)
    <EDARR>
    { return new ArrayInvoke(l,r); }
}

private Operator readMethodInvoke(ExpressContext c, Operator l) throws ExpressException :
{
    String name;
    List<Operator> args = new LinkedList<Operator>();
    Map<String,Operator> namedArgs = new TreeMap<String,Operator>();
    Operator a;
    String argName;
}
{
    (
        <DOT>
        name = readEntityName(c)
        <STCOMP>
        (
              (
                  LOOKAHEAD (2)    
                  (
                      argName = readEntityName(c)
                      <ASSIGNMENT>
                      a = readExpression(c)
                      { namedArgs.put(argName, a); }
                  ) |
                  (
                       a = readExpression(c)
                      { args.add(a); }
                  )
              )
              (
                   <ARGSEP>
                   (
                      LOOKAHEAD (2)
                      (
                          argName = readEntityName(c)
                          <ASSIGNMENT>
                          a = readExpression(c)
                          { namedArgs.put(argName, a); }
                      ) |
                      (
                           a = readExpression(c)
                          { args.add(a); }
                      )
                  )
              )*
         )?
        <EDCOMP>
    )
    {
        return new MethodInvoke(l, name, args, namedArgs);
    }
}

private Operator readUnary(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
      ((<NOT> | <NOT1>)
       o = readValue(c)
       { return new LogicalNot(o); })    
    | 
      (<SUB>
       o = readValue(c)
       { return new Sub(null, o); })
}


private Operator readNew(ExpressContext c) throws ExpressException :
{
    StringBuilder name = new StringBuilder();
    String cn;
    List<Operator> args = new LinkedList<Operator>();
    Operator a;
}
{
    (<NEW>
     cn = readEntityName(c)
     { name.append(cn); }
     (<DOT>
      cn = readEntityName(c)
      { name.append(".").append(cn); })*
     <STCOMP>
     (a = readExpression(c)
      { args.add(a); }
      (<ARGSEP>
       a = readExpression(c)
       { args.add(a); })*)?
     <EDCOMP>)
    { return new NewObject(name.toString(), args); }
}

private Operator readOperator(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    (o = readNew(c)
     | o = readValue(c)
     | o = readUnary(c))
    { return o; }
}

Operator readExpression(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    (LOOKAHEAD(readAssignment(c)) o = readAssignment(c) |
     o = readOrExpression(c))
    { return o; }
}

Operator readWrappedExpression(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    <START_EXPRESSION> 
    o = readExpression(c)
    <END_EXPRESSION>
    { return new Wrapped(o); }
}

Operator readFullExpression(ExpressContext c) throws ExpressException :
{
    Operator op = null;
    ConcatOperator cat = null;
    Operator ret = null;
}
{
    (
        (op = readPlainText(c) | op = readWrappedExpression(c))
        {
            if (ret == null)
            {
                ret = op;
            }
            else
            {
                if (cat == null)
                {
                    cat = new ConcatOperator(ret);
                    ret = cat;
                }
                cat.addOperator(op);
            }
        }
    )*
    {
        return ret;
    }
}

private Operator readAssignment(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readOrExpression(c)
     (
      (<INCASSIGNMENT>
       { l = new Assignment(l, new Add(l, new IntLiteral(1))); }) |
      (<DECASSIGNMENT>
       { l = new Assignment(l, new Sub(l, new IntLiteral(1))); })
     )?
     (
      (<ASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, r); }) |
      (<POWASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Pow(l, r)); }) |
      (<DIVASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Div(l, r)); }) |
      (<MULASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Mul(l, r)); }) |
      (<MODASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Mod(l, r)); }) |
      (<ADDASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Add(l, r)); }) |
      (<SUBASSIGNMENT>
       r = readOrExpression(c)
       { l = new Assignment(l, new Sub(l, r)); })
     )?
    )
    { return l; }
}

private Operator readOrExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readAndExpression(c)
     ((<OR> | <OR1>)
      r = readAndExpression(c)
      { l = new LogicalOr(l, r); }
     )*)
    { return l; }
}

private Operator readAndExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readEqualityExpression(c)
      ((<AND> | <AND1>)
       r = readEqualityExpression(c)
       {l = new LogicalAnd(l,r); }
      )*)
    { return l; }
}

private Operator readEqualityExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (
     l = readCompareExpression(c)
     (
      (
       (
        <EQ> | <EQ1>
       )
       r = readCompareExpression(c)
       { l = new Equals(l,r); }
      )
      |
      (
       (
        <NE> | <NE1>
       )
       r = readCompareExpression(c)
       { l = new NotEquals(l,r); }
      )
     )*
    )
    { return l; }
}

private Operator readCompareExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readAddExpression(c)
      (
    ((<GT> | <GT1>)
     r = readAddExpression(c)
     { l = new GT(l,r); })
    |((<LT> | <LT1>)
     r = readAddExpression(c)
     { l = new LT(l,r); })
    |((<GTEQ> | <GTEQ1>)
     r = readAddExpression(c)
     { l = new GTEQ(l,r); })
    |((<LTEQ> | <LTEQ1>)
     r = readAddExpression(c)
     { l = new LTEQ(l,r); })
      )*)
    { return l; }
}

private Operator readAddExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readMulExpression(c)
      (
         (<ADD>
           r = readMulExpression(c)
           { l = new Add(l,r); })
        |(<SUB>
           r = readMulExpression(c)
           { l = new Sub(l,r); })
      )*
    )
    { return l; }
}

private Operator readMulExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    (l = readPowExpression(c)
      ( 
    (<MUL>
      r = readPowExpression(c)
      { l = new Mul(l,r); })
    |((<DIV> | <DIV1>)
      r = readPowExpression(c)
      { l = new Div(l,r); })
    |(<MOD>
      r = readPowExpression(c)
      { l = new Mod(l,r); })
      )*)
    { return l; }
}

private Operator readPowExpression(ExpressContext c) throws ExpressException :
{
    Operator l;
    Operator r;
}
{
    ( l = readOperator(c)
      ( 
    <POW>
     r = readOperator(c)
     { l = new Pow(l,r); }
      )*)
    { return l; }
}




StatementBlock readFullStatements(ExpressContext c) throws ExpressException :
{
    StatementBlock ret = new StatementBlock();
    Operator op;
    StatementBlock bl;
    PlainWriteStatement pls;
}
{
    (
        (
            pls = readPlainWriteStatement(c)
            { ret.getStatements().add(pls); }
        ) |
        (
            op = readWrappedExpression(c)
            { ret.getStatements().add(new WriteStatement(op)); }
        ) | 
        (
            bl = readWrappedStatements(c)
            { ret.getStatements().add(bl); }
        )
    )*
    {
        return ret;
    }
}

StatementBlock readWrappedStatements(ExpressContext c) throws ExpressException :
{
    StatementBlock r = new StatementBlock(true);
    Statement s;
}
{
    <START_SCRIPT> 
    (
        (
            s = readStatement(c)
            { r.getStatements().add(s); }
        )
    )+
    <END_SCRIPT>
    { return r; }
}

StatementBlock readStatements(ExpressContext c) throws ExpressException :
{
    StatementBlock r = new StatementBlock(false);
    Statement s;
    Operator op;
    PlainWriteStatement pls;
}
{ 
    (
        (
            s = readStatement(c)
            { r.getStatements().add(s); }
        ) |
        (
            <END_SCRIPT>
            (
                (
                    pls = readPlainWriteStatement(c)
                    { r.getStatements().add(pls); }
                ) |
                (
                    op = readWrappedExpression(c)
                    { r.getStatements().add(new WriteStatement(op)); }
                )
            )*
            <START_SCRIPT>
        )
    )*
    { return r; }
}

private Statement readStatement(ExpressContext c) throws ExpressException :
{
    Statement s;
}
{
    (LOOKAHEAD(readIfStatement(c)) s = readIfStatement(c) |
     LOOKAHEAD(readForEachStatement(c)) s = readForEachStatement(c) |
     LOOKAHEAD(readForStatement(c)) s = readForStatement(c) |
     LOOKAHEAD(readWhileStatement(c)) s = readWhileStatement(c) |
     s = readBreakStatement(c)   |
     s = readReturnStatement(c)  |
     s = readExportStatement(c)  |
     s = readIncludeStatement(c) |
     s = readDefaultStatement(c))
    { return s; }
}

private Statement readIfStatement(ExpressContext c) throws ExpressException :
{
    StatementBlock tb;
    StatementBlock fb = null;
    StatementBlock eib;
    Operator eit;
    List<IfStatement.ElseIfStatement> eis = new LinkedList<IfStatement.ElseIfStatement>();
    Operator t;
}
{
    <IF>
    <STCOMP>
    t = readExpression(c)
    <EDCOMP>
    <STARTBLOCK>
    tb = readStatements(c)
    <ENDBLOCK>
    (LOOKAHEAD(2) <ELSE>
     <IF>
     <STCOMP>
     eit = readExpression(c)
     <EDCOMP>
     <STARTBLOCK>
     eib = readStatements(c)
     <ENDBLOCK>
     { eis.add(new IfStatement.ElseIfStatement(eit, eib)); }
    )*
    (<ELSE>
     <STARTBLOCK>
     fb = readStatements(c)
     <ENDBLOCK>
    )?
    { return new IfStatement(t, tb, eis, fb); }
}

private Statement readWhileStatement(ExpressContext c) throws ExpressException :
{
    Operator t;
    StatementBlock b;
}
{
    <WHILE>
    <STCOMP>
    t = readExpression(c)
    <EDCOMP>
    <STARTBLOCK>
    b = readStatements(c)
    <ENDBLOCK>
    { return new WhileStatement(t,b); }
}

private Statement readForStatement(ExpressContext c) throws ExpressException :
{
    StatementBlock b;
    Operator a;
    Operator t;
    Operator i;
}
{
    <FOR>
    <STCOMP>
    a = readAssignment(c)
    <STATEMENT>
    t = readExpression(c)
    <STATEMENT>
    i = readAssignment(c)
    <EDCOMP>
    <STARTBLOCK>
    b = readStatements(c)
    <ENDBLOCK>
    { return new ForStatement(a, t, i, b); }
}

private Statement readForEachStatement(ExpressContext c) throws ExpressException :
{
    StatementBlock blk;
    String var;
    Operator col;
}
{
    <FOR>
    <STCOMP>
    var = readEntityName(c)
    <IN>
    col = readExpression(c)
    <EDCOMP>
    <STARTBLOCK>
    blk = readStatements(c)
    <ENDBLOCK>
    { return new ForEachStatement(var, col, blk); }
}

private IncludeStatement readIncludeStatement(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    (<INCLUDE> o = readExpression(c) <STATEMENT>)
    { return new IncludeStatement(o); }
}

private Statement readDefaultStatement(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    ( o = readExpression(c) <STATEMENT>
    )
    { return new DefaultStatement(o); }
}

private Statement readBreakStatement(ExpressContext c) throws ExpressException :
{
}
{
    (<BREAK>
     <STATEMENT>)
    { return new BreakStatement(); }
}

private Statement readReturnStatement(ExpressContext c) throws ExpressException :
{
    Operator o;
}
{
    (<RETURN>
     o = readExpression(c)
     <STATEMENT>)
    { return new ReturnStatement(o); }
}

private Statement readExportStatement(ExpressContext c) throws ExpressException :
{
    String varName;
}
{
    (<EXPORT>
     varName = readEntityName(c)
     <STATEMENT>)
    { return new ExportStatement(varName); }
}
